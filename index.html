<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

    <!--font-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Orbitron">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=VT323">

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <script
            src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
            integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8="
            crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <style>
        @CHARSET "UTF-8";

        * {
            -webkit-user-select: none;
        }

        html,
        body {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            -webkit-overflow-scrolling: touch;
            background: linear-gradient(#0c122f, #1e2477, #161f52);
        }

        /*baseball*/
        .btn.id, .btn.lvl {
            padding: 0;
        }

        button#replay.focus, button#replay:focus {
            color: #333;
            background-color: white;
            border-color: #8c8c8c;
        }

        .title h1 {
            padding-top: 109px
        }

        input {
            width: 50px;
            height: 50px;
            padding: 5px;
            text-align: center;
            font-size: 40px;
            margin-right: 20px;
        }

        /*숫자 입력칸의 화살표를 삭제*/
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button {
            -webkit-appearance: none !important;
            margin: 0;
        }

        .progress {
            width: 150px;
            margin-bottom: 0px;
            background-color: rgba(245, 245, 245, 0.2);
        }

        .progress-bar {
            /*background-color: #0b5ed7;*/
            background-color: aqua;
        }


        .btn-link {
            color: black;
        }

        .dropdown, .lvl, .exp {
            display: inline-block;
            margin-right: 10px;
        }

        .lvl {
            font-family: 'VT323', monospace;
            font-size: 20px;
        }

        .header {
            margin-right: 0px;
            margin-left: auto;
            height: 45px;
        }

        .logo {
            font-size: 25px;
            font-weight: 100;
            margin: 0;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid rgba(0, 0, 0, .0975);
        }

        .menu {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            height: 45px;
            color: #fff;
            background: linear-gradient(45deg, transparent, #453077);
            box-shadow: 0 0 1px 1px #ffffff1c inset;
        }

        div#min {
            /*top: -20px;*/
            position: relative;
            background-color: red;
            width: 0;
        }

        a#lvl, a#lvl:hover {
            color: black;
        }

        /*반응형에 맞게 마진 조절*/
        @media all and (max-width: 670px) {
            .title {
                margin-top: 0px;
            }
        }


        /*tetris*/
        .tetris-table {
            /*border-spacing: 1px;*/
            /*border-collapse: separate;*/
            position: absolute;
            top: 90px;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tetris-table tbody {
            background: linear-gradient(90deg, #00000047, black, black, black, #00000047);
            border: 1px solid #ffffffb8;
            box-shadow: 0 0 5000px -10px #ffffff36, 0 0 16px 2px #ffffff7a;
        }

        .tetris-table td {
            width: 25px;
            height: 25px;
            border: 1px solid #ffffff1c;
        }

        .game-end {
            color: #fff;
            background-color: rgba(0, 0, 0, 0.2);
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .game-end .replay {
            color: black;
            background-color: #fff;
            border: none;
            border-radius: 25px;
        }


        /*tetrisFight*/
        .tetris-table2 {
            /*border-collapse: collapse;*/
            /*border: 1px solid rgb(232, 232, 232);*/
            margin: auto;
            border-spacing: 1px;
            border-collapse: separate;
            display: inline-flex;
        }

        .tetris-table2 td {
            width: 25px;
            height: 25px;
            /*background-color: rgb(240, 240, 240);*/
        }

        .tetris-table1 {
            /*border-collapse: collapse;*/
            /*border: 1px solid rgb(232, 232, 232);*/
            margin: auto;
            border-spacing: 1px;
            border-collapse: separate;
            display: inline-flex;
        }

        .tetris-table1 td {
            width: 25px;
            height: 25px;
            /*background-color: rgb(240, 240, 240);*/
        }

        .tetris-fight-tables {
            text-align: center;
            margin: 50px auto;
            display: flex;

        }

        .wait-player {
            margin: auto;
            border-spacing: 1px;
            border-collapse: separate;
            display: inline-flex;
            width: 261px;
            height: 573px;
            padding-top: 200px;
            padding-left: 60px;
        }


        /*반응형에 맞게 마진 조절*/

        .btn.id, a#lvl, a#lvl:hover {
            color: white;
        }

        .exp {
            margin-right: 20px;
        }

        .game-title {
            position: absolute;
            left: 20px;
            color: #fff;
            font-weight: 700;
            font-size: 14px;
        }

        @media all and (max-width: 670px) {
            .logo {
                height: 12vw;
            }

            .menu {
                height: 12vw;
            }

            .tetris-table {
                top: 24vw;
            }

            .tetris-table td {
                width: 5vw;
                height: 5vw;
            }

            .btn.id {
                font-size: 3.5vw;
            }

            .btn.lvl {
                font-size: 4.5vw;
            }

            .progress {
                width: 25vw;
            }

            /*.game-end {*/
            /*    top: 0;*/
            /*}*/

            .dropdown, .lvl, .exp {
                margin-right: 2vw;
            }

            .game-title {
                left: 4vw;
                font-size: 3.5vw;
            }
        }

        .tetris-block-empty {
            /*background: rgba(51, 51, 51, 0.4);*/
            border: none;
            box-shadow: none;
        }
        .tetris-table .tetris-block {
            box-shadow: 0 0 3px 1px #ffffff inset, 0 0 20px 1px #ffffffab;
        }
        /*cyan*/
        .tetris-block-0 {
            background: linear-gradient(135deg, #92f9f4, #05d8f3 60%, #148ccd);
        }
        /*yellow*/
        .tetris-block-1 {
            background: linear-gradient(135deg, #fdf2d7, #fddb18 60%, #c4730f);
        }
        /*violet*/
        .tetris-block-2 {
            background: linear-gradient(135deg, #fdd2fb, #fe4fea 60%, #400ba5);
        }
        /*green*/
        .tetris-block-3 {
            background: linear-gradient(135deg, #ecf268, #1ccb11 60%, #068b11);
        }
        /*red*/
        .tetris-block-4 {
            background: linear-gradient(135deg, #f78fa8, #f21421 60%, #920c11);
        }
        /*blue*/
        .tetris-block-5 {
            background: linear-gradient(135deg, #2cdbf7, #0b5ed7 60%, #083bad);
        }
        /*orange*/
        .tetris-block-6 {
            background: linear-gradient(135deg, #fcca72, #fc7e0d 60%, #eb4a06);
        }
    </style>
    <title>Tetris</title>
</head>
<body>


<!--헤더-->
<div class="header">
<!--    <div class="logo">sooheesong.com</div>-->

    <div class="menu">
        <!--로그인 이름-->
        <!--<div class="dropdown">-->
        <!--<button class="id btn btn-link dropdown-toggle" type="button" data-toggle="dropdown">-->
        <!--{{userNameList[userNameIdx]}}-->
        <!--</button>-->
        <!--<ul class="dropdown-menu">-->
        <!--<li><a href="#">[비밀번호 변경]</a></li>-->
        <!--<li><a href="#">[로그아웃]</a></li>-->
        <!--</ul>-->
        <!--</div>-->
        <!--끝 - 로그인 이름-->

        <!--<div class="game-logo">-->
        <!--<img src="img/Tetris-350x288.png">-->
        <!--</div>-->
        <div class="game-title">TETRIS</div>
        <!--레벨정보-->
        <div>
            <button class="lvl btn btn-link" type="button">
                <a id="lvl" href="#">Lv. 0</a>
            </button>
        </div>
        <!--끝 - 레벨정보-->

        <!--경험치 정보-->
        <div class="exp">
            <div class="progress">
                <div id="pro" class="progress-bar"></div>
                <div id="min" class="progress-bar"></div>
            </div>
        </div>
        <!--끝 - 경험치 정보-->
    </div>
</div>
<!--끝 - 헤더-->

<table class="tetris-table">
    <tbody id="tetris_table">
    </tbody>
</table>
<div class="game-end" style="display: none;">
    <!--다시하기 버튼-->
    <button id="replay" onclick="replay()" class="btn btn-default replay">replay</button>
    <!--끝 - 다시하기 버튼-->
</div>

<div id="key" style="display: none;"></div>
</body>
</html>

<script>
  var tetrisTable = '';
  for (var r = 1; r < 23; r++) {
    tetrisTable += '<tr>'
    for (var d = 0; d < 10; d++) {
      tetrisTable += '<td class="td' + r + d + '"></td>';
    }
    tetrisTable += '</tr>'
  }
  document.getElementById('tetris_table').innerHTML = tetrisTable;

  var idx, rotate, block = [];
  var h_loc, v_loc;
  var up, bottom, left, right;

  var obstacle = false;

  var godown, downtime = 500;

  var tdcss;
  var i, k;

  var black = [];
  var full = [];

  var x, y;

  var min = [], max = [];

  var line = 0, cnt = 0;
  var point = 0, level = 0;
  var newPoint, oldPoint, minPoint;
  var color;

  var clean;
  var game_end = false;


  //블럭 종류별로 생성
  var blocks = [];

  blocks[0] = [
    [10, 11, 12, 13],
    [11, 21, 31, 41],
    [10, 11, 12, 13],
    [12, 22, 32, 42]
  ];
  blocks[1] = [
    [10, 11, 20, 21],
    [10, 11, 20, 21],
    [10, 11, 20, 21],
    [10, 11, 20, 21]
  ];
  blocks[2] = [
    [11, 20, 21, 22],
    [11, 20, 21, 31],
    [10, 11, 12, 21],
    [11, 21, 22, 31]
  ];
  blocks[3] = [
    [11, 12, 20, 21],
    [10, 20, 21, 31],
    [11, 12, 20, 21],
    [11, 21, 22, 32]
  ];
  blocks[4] = [
    [10, 11, 21, 22],
    [11, 20, 21, 30],
    [10, 11, 21, 22],
    [12, 21, 22, 31]
  ];
  blocks[5] = [
    [10, 20, 21, 22],
    [11, 21, 30, 31],
    [10, 11, 12, 22],
    [11, 12, 21, 31]
  ];
  blocks[6] = [
    [12, 20, 21, 22],
    [10, 11, 21, 31],
    [10, 11, 12, 20],
    [11, 21, 31, 32]
  ];

  var qnt = [
    "#05d8f3", // aqua
    "#fddb18", // yellow
    "#fe4fea", // violet
    "#1ccb11", // green
    "#f21421", // red
    "#0b5ed7", // blue
    "#fc7e0d" // orange
  ];
  var qntlight = [
    "#92f9f4",
    "#fdf2d7",
    "#fdd2fb",
    "#ecf268",
    "#f78fa8",
    "#2cdbf7",
    "#fcca72"
  ]
  var qntdark = [
    "#148ccd",
    "#c4730f",
    "#400ba5",
    "#068b11",
    "#920c11",
    "#083bad",
    "#eb4a06"
  ]

  //rgb(232, 232, 232)

  //테이블 인식 생성
  for (i = 0; i < 23; i++) {
    black.push([]);
    full.push(0);
    for (k = 0; k < 10; k++) {
      black[i].push(null);                            //[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    }
  }
  console.table([black]);
  console.log(JSON.stringify(full));

  //key
  var key = document.getElementById("key");
  var stop = false;
  //입력받는다
  document.addEventListener("keydown", function (event) {
    console.log(event);
    key.innerHTML = event.code;

    if (game_end === false) {
      switch (event.code) {
        case "ArrowLeft":
          if (stop == false)
            go_left();
          break;
        case "ArrowRight":
          if (stop == false)
            go_right();
          break;
        case "Escape":
          if (stop == false) {
            stop_block();
          } else {
            block_down(downtime);
          }
          stop = !stop;
          break;
        case "Space":
          if (block == "") {
            create_block();
          } else if (stop == true) {
            block_down();
            stop = !stop;
          } else if (stop == false) {
            // 블럭을 맨 밑으로
            spacebar();
          }
          break;
        case "ArrowDown":
          go_down();
          break;
        case "ArrowUp":
          rotate_left();
          break;

        case "KeyC":
          row_clean();
          break;
      }
    }
  });

  var touchstartX, touchstartY, touchendX, touchendY, angle, touchstartT, touchendT;
  var move, movestartX, movestartY, moved, wentDown, rotateleft;
  document.addEventListener("touchstart", function (event) {
    touchstartX = event.touches[0].clientX;
    touchstartY = event.touches[0].clientY;
    touchendX = event.touches[0].clientX;
    touchendY = event.touches[0].clientY;
    movestartX = touchstartX;
    movestartY = touchstartY;
    move = false;
    moved = false;
    wentDown = false;
    touchstartT = (new Date()).getTime();
    rotateleft = false;
  });

  document.addEventListener("touchmove", function (event) {
    touchendX = event.touches[0].clientX;
    touchendY = event.touches[0].clientY;
    angle = Math.atan2(touchendY - touchstartY, touchendX - touchstartX) * 180 / Math.PI;

    if (!move && Math.abs(touchendY - movestartY) > 30 || Math.abs(touchendX - movestartX) > 15) {
      movestartX = touchendX;
      movestartY = touchendY;
      move = true;
    }

    if (!game_end && !stop && move) {
      // left
      if ((angle < -135 && angle >= -180) || (angle > 135 && angle <= 180)) {
        go_left();
        wentDown = false;
      }
      // right
      if ((angle > -45 && angle <= 0) || (angle >= 0 && angle < 45)) {
        go_right();
        wentDown = false;
      }
      // down
      if (angle > 45 && angle < 135) {
        go_down();
        wentDown = true;
      }
      move = false;
      moved = true;
    }

  });

  document.addEventListener("touchend", function (event) {

    touchendT = (new Date()).getTime();
    if (!moved && touchendT - touchstartT <= 300) {
      rotateleft = true;
    }

    if (game_end === false) {

      if (block == "") {
        create_block();
      } else if (stop == true) {
        block_down();
        stop = !stop;
      } else if (stop == false) {
        if (wentDown) {
          // 블럭을 맨 밑으로
          spacebar();
        } else if (!moved && rotateleft) {
          rotate_left();
        }
      }

      event.preventDefault();
    }

  });

  function create_block() {
    move = false;

    h_loc = 3;

    // 0~6 랜덤 숫자 생성 (최대, 최소값 포함: Math.floor(Math.random() * (max - min + 1)) + min;)
    idx = Math.floor(Math.random() * (6 + 1));

    console.log("color: " + color);

    // rotate 상태: 0번째
    rotate = 0;

    //블럭을 생성
    block = blocks[idx][rotate].slice(0);
    //블럭을 중앙에 위치
    for (i = 0; i < block.length; i++) {
      block[i] += h_loc;
    }
    for (i = 0; i < block.length; i++) {
      y = Math.floor((block[i] / 10));
      x = block[i] % 10;
      //블럭에 블럭이 이미 있으면
      if (black[y][x] !== null) {
        obstacle = true;
        break;
      } else {
        obstacle = false;
      }
    }
    if (obstacle == false) {
      //화면에 블럭 표시
      color_block();
      console.log("idx: " + idx);
      console.log("block : " + JSON.stringify(block));
      console.log("blocks : " + JSON.stringify(blocks));
      block_edge();

      if (line < 4) {
        downtime = 1000;
      } else if (line < 8) {
        downtime = 800;
      } else if (line < 12) {
        downtime = 600;
      } else {
        downtime = 500;
      }
      block_down(downtime);

    } else {
      //게임종료
      game_end = true;
      stop_block();
      // $(".tetris-table").css("display", "none");
      $(".game-end").css("display", "flex");
    }
  }

  function block_down(downtime) {
    godown = setInterval(go_down, downtime);
  }

  function stop_block() {
    clearInterval(godown);
  }

  function spacebar() {
    stop_block();
    block_down(5);
  }

  function go_down() {
    if (bottom !== 22) {
      //이동하려는 칸이 채워져있는지 확인(block이 1이면 채워져 있는 것)
      for (i = 0; i < block.length; i++) {
        y = Math.floor((block[i] / 10));
        x = block[i] % 10;
        //블럭의 아래
        console.log("y: " + y);
        console.log("x: " + x);
        console.log("black[" + (y + 1) + "][" + x + "]: " + black[y + 1][x]);
        if (black[y + 1][x] !== null) {
          obstacle = true;
          break;
        } else {
          obstacle = false;
        }
      }
      if (obstacle === false) {
        clear_block();
        //부품 하나씩 아래로 보내줘야함.
        for (i = 0; i < block.length; i++) {
          block[i] += 10;
        }
        up++;
        bottom++;
        //화면에 블럭 표시
        color_block();
      } else {
        //현재블럭 정지
        clearInterval(godown);
        //black에 저장
        for (i = 0; i < block.length; i++) {
          y = Math.floor((block[i] / 10));
          x = block[i] % 10;
          black[y][x] = idx;

        }
        console.log(JSON.stringify(black));
        //화면에 블럭 표시
        color_block();
        //줄이 모두 채워졌으면 삭제
        row_clean();
        if (clean === 0) {
          console.log("clean !== 0: " + Boolean(clean !== 0));
          //새로운 블럭 생성
          create_block();
          console.log("create_block clean false");
        }
      }
    } else {
      //현재블럭 정지
      clearInterval(godown);
      //black에 저장
      for (i = 0; i < block.length; i++) {
        y = Math.floor((block[i] / 10));
        x = block[i] % 10;
        black[y][x] = idx;

      }
      console.log(JSON.stringify(black));
      //화면에 블럭 표시
      color_block();
      //줄이 모두 채워졌으면 삭제
      row_clean();
      if (clean === 0) {
        console.log("clean !== 0: " + Boolean(clean !== 0));
        //새로운 블럭 생성
        create_block();
        console.log("create_block clean false");
      }
    }
  }

  function go_left() {
    if (left !== 0) {
      for (i = 0; i < block.length; i++) {
        y = Math.floor((block[i] / 10));
        x = block[i] % 10;
        if (black[y][x - 1] !== null) {
          obstacle = true;
          break;
        } else {
          obstacle = false;
        }
      }
      if (obstacle === false) {
        clear_block();
        //부품 하나씩 왼쪽으로 보내줘야함.
        for (i = 0; i < block.length; i++) {
          block[i] -= 1;
        }
        left--;
        right--;
        h_loc--;
        //화면에 블럭 표시
        color_block();
      }
    }
  }

  function go_right() {
    if (right !== 9) {
      for (i = 0; i < block.length; i++) {
        y = Math.floor((block[i] / 10));
        x = block[i] % 10;
        if (black[y][x + 1] !== null) {
          obstacle = true;
          break;
        } else {
          obstacle = false;
        }
      }
      if (obstacle === false) {
        clear_block();
        //부품 하나씩 오른쪽으로 보내줘야함.
        for (i = 0; i < block.length; i++) {
          block[i]++;
        }
        left++;
        right++;
        h_loc++;
        //화면에 블럭 표시
        color_block();
      }
    }
  }

  //rotate를 기준으로 생성되고 rotate 됐을 때
  function block_edge() {

    y = [];
    x = [];
    for (i = 0; i < block.length; i++) {
      y.push(Math.floor((block[i] / 10)));
      x.push(block[i] % 10);
    }

    up = Math.min.apply(null, y);
    bottom = Math.max.apply(null, y);
    left = Math.min.apply(null, x);
    right = Math.max.apply(null, x);

    console.log("top: " + up);
    console.log("bottom: " + bottom);
    console.log("left: " + left);
    console.log("right: " + right);
  }

  function rotate_left() {
    //높이를 더해줄 것이기 때문에 -1 해줌
    v_loc = up - 1;
    //현상태 파악 및 회전할 블럭 선택
    if (rotate !== 3) {
      rotate++;
    } else if (rotate = 3) {
      rotate = 0;
    }

    //현재 블럭 해제
    clear_block();
    //회전
    block = blocks[idx][rotate].slice(0);

    console.log("block: " + block);
    //위치조정
    //x위치 조정
    x = [];
    y = [];
    for (i = 0; i < block.length; i++) {
      y.push(Math.floor((block[i] / 10)) + v_loc);
      x.push(block[i] % 10 + h_loc);
    }
    console.log("x : " + x);
    min = Math.max.apply(null, y);
    max = Math.max.apply(null, x);
    console.log("max : " + max);
    //오른쪽으로 9보다 넘어갔을 때
    console.log("black[" + up + "][" + max + "] : " + black[up][max]);
    console.log("black[" + up + "][" + max + "] === 1: " + Boolean(black[up][max] !== null));
    if (max > 9) {
      h_loc -= max - 9;
      //오른쪽에 블럭이 있을 때
    }
    if (min > 22) {
      v_loc -= min - 22;
    }
    for (i = 0; i < block.length; i++) {
      block[i] += h_loc + v_loc * 10;
    }
    block_edge();
    // 오른쪽 혹은 아래에 블럭이 있을 때
    console.log("block: " + block);

    //블럭 표시
    color_block();
  }

  function classNameLikeTetrisBlock(index, className) {
      return 'tetris-block ' + (className.match(/(^|\s)tetris-block\S+/g) || []).join(' ');
  }

  function clear_block() {
    for (i = 0; i < block.length; i++) {
      tdcss = "td.td" + block[i];
        $(tdcss).removeClass(classNameLikeTetrisBlock).addClass('tetris-block-empty');
    }
  }

  function row_clean() {
    clean = 0;
    //삭제할 행들을 찾아낸다
    for (y = 0; y < 23; y++) {
      for (x = 0; x < 10; x++) {
        if (black[y][x] === null) {
          full[y] = 0;
          break;
        } else {
          full[y] = 1;
        }
      }
      clean += full[y];
    }

    console.log("full: " + full);
    console.log("clean !== 0: " + Boolean(clean !== 0));
    if (clean !== 0) {
      console.log("full: " + full);
      for (y = 22; y > 0; y--) {
        if (full[y] === 1) {
          for (x = 0; x < 10; x++) {
            tdcss = "td.td" + y + x;
              $(tdcss).removeClass(classNameLikeTetrisBlock).addClass('tetris-block-empty');
          }
        }
      }

      setTimeout(function () {

        for (y = 22; y > 0; y--) {
          if (full[y] === 1) {
            for (x = 0; x < 10; x++) {
              tdcss = "td.td" + y + x;
              // color = qnt[black[y][x]];
                // $(tdcss).removeClass(classNameLikeTetrisBlock);
              $(tdcss).removeClass(classNameLikeTetrisBlock).addClass('tetris-block tetris-block-' + black[y][x]);
            }
          }
        }

      }, 100);

      setTimeout(function () {
        console.log("full: " + full);
        for (y = 22; y > 0; y--) {
          if (full[y] === 1) {
            for (x = 0; x < 10; x++) {
              tdcss = "td.td" + y + x;
                $(tdcss).removeClass(classNameLikeTetrisBlock).addClass('tetris-block-empty');
            }
          }
        }

      }, 200);

      setTimeout(function () {
        console.log("cnt: " + cnt);
        for (i = 22; i >= 0; i--) {
          console.log(full[i]);
          if (full[i] === 1) {
            cnt++;
            line++;
            full[i] = 0;
          } else if (cnt !== 0) {
            //없어진 줄만큼 밑으로
            for (y = i; y >= 0; y--) {
              for (x = 0; x < 10; x++) {
                black[y + cnt][x] = black[y][x];
                tdcss = "td.td" + (y + cnt) + x;
                if (black[y + cnt][x] === null) {
                    $(tdcss).removeClass(classNameLikeTetrisBlock).addClass('tetris-block-empty');
                } else {
                    $(tdcss).removeClass(classNameLikeTetrisBlock).addClass('tetris-block tetris-block-' + black[y + cnt][x]);
                }

              }
            }
            point_line();
            i += cnt;
            cnt = 0;
          }
        }
        //새로운 블럭 생성
        create_block();
      }, 300);
    }

  }

  function color_block() {
    color = qnt[idx];
    for (i = 0; i < block.length; i++) {
      tdcss = "td.td" + block[i];
        $(tdcss).removeClass(classNameLikeTetrisBlock).addClass('tetris-block tetris-block-' + idx);
    }
  }


  function point_line() {
    var min = document.getElementById("min");
    var pro = document.getElementById("pro");
    var lvl = document.getElementById("lvl");

    //연습모드
    //없앤 line을 센다
    //line * 10만큼 점수가 오른다.
    //100을 넘어가면 레벨이 오른다.

    //대결모드
    //이겼는지 졌는지 확인
    //이겼으면 없앤 줄만큼 점수가 오른다.
    //졌으면 이긴 사람이 얻은 점수만큼 줄어든다.

    //최종 점수를 계산한다.
    newPoint = cnt * 10 + point;
    oldPoint = point;

    $(min).css("transition", "width .6s ease");
    $(pro).css("transition", "width .6s ease");

    $(min).css("background-color", "#85ffff");

    //점수가 100 이상이면 레벨 업
    if (newPoint >= 100) {
      newPoint -= 100;
      minPoint = 100 - oldPoint;
      level++;
      //min: 추가된 점수만큼 생성
      $(min).css("width", minPoint + "%");
      //pro: 100%
      //min: 0
      setTimeout(function () {
        $(min).css("width", "0");
        $(pro).css("width", "100%");
      }, 600);
      //pro: 0
      setTimeout(function () {
        $(pro).css("transition", "none");
        $(pro).css("width", "0");
      }, 700);
      //min: 점수만큼 생성
      setTimeout(function () {
        $(min).css("width", newPoint + "%");
//                        $(min).text("+" + newPoint);
      }, 800);
      //pro: 점수만큼 생성
      //min: 0
      setTimeout(function () {
        $(min).css("width", "0");
        $(pro).css("transition", "width .6s ease");
        $(pro).css("width", newPoint + "%");
        lvl.innerHTML = "Lv. " + level;
        $(lvl).fadeOut().fadeIn().fadeOut().fadeIn();
        // setTimeout(function () {
        //   $(lvl).css("color", "#fff");
        // }, 1600);
      }, 1400);

      //레벨에 변동이 없으면
    } else {
      minPoint = newPoint - oldPoint;
      $(min).css("width", minPoint + "%");
      setTimeout(function () {
        $(min).css("width", "0");
        $(pro).css("width", newPoint + "%");
      }, 600);

    }
    point = newPoint;
    //db와 session에 점수를 저장한다.
    var pntLvl = {};
    pntLvl["newPoint"] = newPoint;
    pntLvl["newLevel"] = level;

    // $.ajax({
    //   type: "POST",
    //   contentType: "application/json",
    //   url: "tetris",
    //   data: JSON.stringify(pntLvl),
    //   dataType: 'json'
    // });

  }

  function replay() {
    location.reload();
  }
</script>
